// Objects.h
#ifndef OBJECTS_H
#define OBJECTS_H
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <vector>
#include <string>
#include <functional>

#include <useful.h>

class ObjectManager {
public:
	ObjectManager() : objectsUpdated(true) {};

	void setObjectsUpdated(bool updated) {
		objectsUpdated = updated;
	}

	void addObject(GameObject* object) {
		objects.push_back(object);
		objectsUpdated = true;
	}

	void destroyObject(GameObject* object) {
		objects.erase(std::remove(objects.begin(), objects.end(), object), objects.end());
		objectsUpdated = true;
	}

	GameObject* getObjectByName(std::string name) {
		for (auto& object : objects) {
			if (object->name == name) {
				return object;
			}
		}
		return nullptr;
	}

	bool haveObjectsUpdated() {
		if (objectsUpdated) {
			objectsUpdated = false;
			return true;
		}
		return false;
	}

	std::vector<std::vector<glm::vec3>> getAllVertices() {
		// Returns a Vector(Vector(Vertex)) of every object
		std::vector<std::vector<glm::vec3>> vertices;
		for (auto& object : objects) {
			vertices.push_back(object->vertices);
		}
		return vertices;
	}

	void addCube(float width, float height, float depth, glm::vec3 bottomLeft, std::string name) {
		std::vector<glm::vec3> vertices;

		// Define the 8 vertices of the cube
		glm::vec3 v0 = bottomLeft;
		glm::vec3 v1 = bottomLeft + glm::vec3(width, 0.0f, 0.0f);
		glm::vec3 v2 = bottomLeft + glm::vec3(width, height, 0.0f);
		glm::vec3 v3 = bottomLeft + glm::vec3(0.0f, height, 0.0f);
		glm::vec3 v4 = bottomLeft + glm::vec3(0.0f, 0.0f, depth);
		glm::vec3 v5 = bottomLeft + glm::vec3(width, 0.0f, depth);
		glm::vec3 v6 = bottomLeft + glm::vec3(width, height, depth);
		glm::vec3 v7 = bottomLeft + glm::vec3(0.0f, height, depth);

		// Front face
		vertices.insert(vertices.end(), { v0, v1, v2, v2, v3, v0 });

		// Back face
		vertices.insert(vertices.end(), { v4, v5, v6, v6, v7, v4 });

		// Left face
		vertices.insert(vertices.end(), { v0, v3, v7, v7, v4, v0 });

		// Right face
		vertices.insert(vertices.end(), { v1, v2, v6, v6, v5, v1 });

		// Top face
		vertices.insert(vertices.end(), { v3, v2, v6, v6, v7, v3 });

		// Bottom face
		vertices.insert(vertices.end(), { v0, v1, v5, v5, v4, v0 });

		GameObject* cube = new GameObject(vertices, bottomLeft, name, this);
		addObject(cube);
	}

private:
	std::vector<GameObject*> objects = {
		new GameObject({glm::vec3(0.0f, 0.0f, 0.0f)}, glm::vec3(0.0f, 0.0f, 0.0f), "origin", this)
	};
	bool objectsUpdated;
};

class GameObject {
public:
	glm::vec3 position; // central vertex position all rotations are based about, would make sense to have this as the centre of the object
	glm::vec3 rotation = glm::vec3(0.0f, 0.0f, 0.0f);
	std::vector<glm::vec3> vertices;
	std::string name;
	ObjectManager* manager;

	GameObject(std::vector<glm::vec3> verts, glm::vec3 pos, std::string handle, ObjectManager* mgr) : vertices(verts), position(pos), name(handle), manager(mgr) {

	};

	void move(glm::vec3 change) {
		position += change;
		for (auto& vert : vertices) {
			vert += change;
		}
		manager->setObjectsUpdated(true);
	}

	void rotate(glm::vec3 rotation) {
		for (auto& vert : vertices) {
			vert = vec3RotateAroundPoint(rotation, position, vert);
		}
		manager->setObjectsUpdated(true);
	}

	void scale(glm::vec3 scale) {
		position = scale * position;
		for (auto& vert : vertices) {
			vert = scale * vert;
		}
		manager->setObjectsUpdated(true);
	}
};
#endif